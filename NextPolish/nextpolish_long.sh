#!/bin/bash

# do the long read polishing manually

# Set input and parameters
round=2 # do long-read polishing for 2 rounds. To me, 2 rounds is enough
threads=48
read="path/sample_all_ont.fastq.gz" # specify the path of the ont long reads
read_type=ont #{clr,hifi,ont}, clr=PacBio continuous long read, hifi=PacBio highly accurate long reads, ont=NanoPore 1D reads
mapping_option=(["clr"]="map-pb" ["hifi"]="asm20" ["ont"]="map-ont") # don't edit this line
input="path/nextdenovo.asm.fasta" # specify the path of the primary assembly generated by NextDenovo
nextpolish2="/home/yutachen/anaconda3/envs/nextpolish/share/nextpolish-1.4.1/lib/nextpolish2.py" # specify the path to NextPolish

# minimap2 parameters
size=20G # this corresponding to -I option of minimap2, change according to your computatioinal resources
mem=20G # this corresponding to -K option of minimap2, change according to your computatioinal resources

### don't edit lines below, only if you know what you are doing

for ((i=1; i<=${round};i++)); do
    minimap2 -ax ${mapping_option[$read_type]} -2 -I ${size} -K ${mem} -t ${threads} ${input} ${read} > lgs.sam;
    samtools sort -m 2g --threads ${threads} -o lgs.sort.bam lgs.sam;
    rm lgs.sam;
    samtools index lgs.sort.bam;
    ls `pwd`/lgs.sort.bam > lgs.sort.bam.fofn;
    python ${nextpolish2} -g ${input} -l lgs.sort.bam.fofn -r ${read_type} -p ${threads} -sp -o genome.nextpolish.fa;
    if ((i!=${round}));then
        mv genome.nextpolish.fa genome.nextpolishtmp.fa;
        input=genome.nextpolishtmp.fa;
    fi;
done;

if [ $? -eq 0 ] && [ -s genome.nextpolish.fa ]
then
    mv genome.nextpolish.fa genome.nextpolish.long.fa
    echo 'Finally polished genome file: genome.nextpolish.long.fa'
    rm lgs.sort.bam lgs.sort.bam.bai lgs.sort.bam.fofn genome.nextpolishtmp.fa
else
    echo "program died"
fi
